<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .cell {
        width: 8px;
        height: 8px;
        border: 1px solid white;
        float: left;
        background: #000;
      }
      .cell_color {
        background: red;
      }
      .bodyClass {
        width: 1000px;
        height: 1000px;
      }
      .search {
        background-color: greenyellow;
      }
      .pink {
        background-color: pink;
      }
    </style>
  </head>
  <body>
    <button onclick="localStorage.app = JSON.stringify(app)">save</button>
    <div class="bodyClass"></div>
  </body>

  <script>
    class BinaryHeap {
      constructor(data, compare) {
        this.data = data;
        this.compare = compare;
      }
      take() {
        if (!this.data.length) return;
        let min = this.data[0];
        let i = 0;

        while (i < this.data.length) {
          if (i * 2 + 1 >= this.data.length) break;
          if (i * 2 + 2 >= this.data.length) {
            this.data[i] = this.data[i * 2 + 1];
            i = i * 2 + 1;
            break;
          }

          if (this.compare(this.data[i * 2 + 1], this.data[i * 2 + 2]) < 0) {
            this.data[i] = this.data[i * 2 + 1];
            i = i * 2 + 1;
          } else {
            this.data[i] = this.data[i * 2 + 2];
            i = i * 2 + 2;
          }
        }
        if (i < this.data.length - 1) this.insertAt(i, this.data.pop());
        else this.data.pop();

        return min;
      }
      insertAt(i, v) {
        this.data[i] = v;
        while (this.compare(v, this.data[Math.floor((i - 1) / 2)]) < 0) {
          this.data[i] = this.data[Math.floor((i - 1) / 2)];
          this.data[Math.floor((i - 1) / 2)] = v;
          i = Math.floor((i - 1) / 2);
        }
      }
      insert(v) {
        this.insertAt(this.data.length, v);
      }
      get length() {
        return this.data.length;
      }
    }

    let mmm = new BinaryHeap([], (a, b) => b - a);

    let state = false,
      leftButton = false;

    const p = document.querySelector('.bodyClass');
    const app = localStorage.map
      ? JSON.parse(localStorage.map)
      : new Array(10000).fill(0);
    let a = document.createDocumentFragment();
    for (let i = 0; i < 100; i++) {
      for (let k = 0; k < 100; k++) {
        let c = document.createElement('div');
        c.addEventListener('mousemove', (event) => move(i, k));
        c.classList.add('cell');
        a.appendChild(c);
      }
    }
    p.appendChild(a);
    document.addEventListener('contextmenu', (e) => {
      e.preventDefault();
    });
    document.addEventListener('mousedown', (e) => {
      if (e.button === 2) {
        leftButton = true;
      } else {
        state = true;
      }
    });
    document.addEventListener('mouseup', (e) => {
      if (e.button === 2) {
        leftButton = false;
      } else {
        state = false;
      }
    });
    function move(i, k) {
      if (state) {
        console.log('y', i, 'x', k);
        p.children[i * 100 + k].classList.add('cell_color');
        app[i * 100 + k] = 1;
      }
      if (leftButton) {
        p.children[i * 100 + k].classList.remove('cell_color');
        app[i * 100 + k] = 0;
      }
    }

    function sleep(t) {
      return new Promise((res) => {
        setTimeout(res, t);
      });
    }

    class Sorted {
      constructor(data, compare) {
        this.data = data;
        this.compare = compare;
      }
      take() {
        if (!this.data.length) return;
        let min = this.data[0];
        let index = 0;
        for (let i = 0; i < this.data.length; i++) {
          if (this.compare(this.data[i], min) > 0) {
            min = this.data[i];
            index = i;
          }
        }
        this.data[index] = this.data[this.data.length - 1];
        this.data.pop();
        return min;
      }
      insert(v) {
        this.data.push(v);
      }
      dataLength() {
        return this.data.length;
      }
    }

    async function findPath(map, start, end) {
      let _map = map.slice();
      // let queue = [start];
      function distance([y, x]) {
        return (y - end[0]) ** 2 + (x - end[1]) ** 2;
      }
      let sorted = new Sorted([start], (a, b) => distance(b) - distance(a));
      async function insert(y, x, pre) {
        if (_map[y * 100 + x] !== 0) {
          return;
        }
        if (y < 0 || x < 0 || y >= 100 || x >= 100) return;
        _map[100 * y + x] = pre;
        p.children[100 * y + x].classList.add('search');
        await sleep(5);

        sorted.insert([y, x]);
      }
      // map = map.slice();

      while (sorted.dataLength()) {
        let [y, x] = sorted.take();
        if (y === end[0] && x === end[1]) {
          let path = [];
          while (y !== start[0] || x !== start[1]) {
            path.push([y, x]);
            p.children[y * 100 + x].classList.add('pink');
            await sleep(5);
            [y, x] = _map[y * 100 + x];
          }
          return path;
        }
        await insert(y, x - 1, [y, x]);
        await insert(y, x + 1, [y, x]);
        await insert(y - 1, x, [y, x]);
        await insert(y + 1, x, [y, x]);

        // await insert(y + 1, x - 1, [y, x]);
        // await insert(y - 1, x - 1, [y, x]);
        // await insert(y - 1, x + 1, [y, x]);
        // await insert(y + 1, x + 1, [y, x]);
        // 右上
        if (map[y * 100 + x + 1] !== 1 || map[(y + 1) * 100 + x] !== 1) {
          await insert([y + 1, x + 1], [y, x]);
        }

        // 右下
        if (map[y * 100 + x + 1] !== 1 || map[(y - 1) * 100 + x] !== 1) {
          await insert([y + 1, x - 1], [y, x]);
        }

        // 左上
        if (map[y * 100 + x - 1] !== 1 || map[(y + 1) * 100 + x] !== 1) {
          await insert([y - 1, x + 1], [y, x]);
        }

        // 左下
        if (map[y * 100 + x - 1] !== 1 || map[(y - 1) * 100 + x] !== 1) {
          await insert([y - 1, x - 1], [y, x]);
        }
      }
    }
  </script>
</html>
